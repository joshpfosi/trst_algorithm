#!/usr/bin/python2
import sys
import math
import re
from kivy.graphics import *
from kivy.app import App
from kivy.animation import Animation
from kivy.uix.relativelayout import RelativeLayout
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.gridlayout import GridLayout
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.label import Label
from kivy.clock import Clock
from kivy.uix.widget import Widget
from random import randint, choice
from time import sleep
from threading import Thread
from collections import deque
from kivy.properties import StringProperty, BooleanProperty, NumericProperty
from kivy.config import Config
from kivy.uix.button import Button
from functools import partial

# This file defines the logic for the gui
# The basic idea is that a static map image of large enough size is used
# with known reference latitudes / longitudes allowing for a lat / lon to 
# pixel conversion

# The code reads from stdin (stdinRead) expecting alternating lines of 
# algorithm
# human
# algorithm
# human...
# data, which it loads into a queue, representing each line as a dictionary
# with keys that give meaning to the floats (see stdinRead)

# Using Clock, a scheduled callback is called every BAUD_RATE seconds which
# updates the screen with the next line of algor/human data - this is flexible
# for when we actually implement the algorithm and need to test it

# The rest is pretty much just logic to make that happen and widget declarations
# NOTE: In Kivy, you "need" a Python class to have a .kv representation of it
#       A class which does nothing but visually appears uses the keyword "pass"
#       which is Pythonic for "Nothing to see here, define and move on"

# NOTE: This file expects stdin! Give it:

# ! kivy main.py < data.txt

# The data.txt file is generated by data_gen.py - feel free to add new data
# as widgets which display that data are implemented

# TODO (in no particular order)
# * Add latitude and longitude to the GUI on mouseover (i.e. the latlon of 
#    the mouse)
# * Any cosmetic changes you like!
# * Add wind speed, apparent wind direction, and apparent wind speed test data
#    to data_gen.py
# * Add Pause button to pause callback

maxLon =  -71.147237        # top right longitude
maxLat =   42.431960        # top right latitude
minLon =  -71.148567        # bottom left longitude
minLat =   42.431365        # bottom left latitude

# image dimensions in pixels
MAP_WIDTH  = 957
MAP_HEIGHT = 700

# width of side nav bars
SIDEBAR = 200
NAVBAR = 50

# fake baud rate
BAUD_RATE = 1

def latToY(targetLat):
    """
    Returns pixel representation of latitude using given reference coords
    """
    return ((targetLat - minLat) / (maxLat - minLat)) * (MAP_HEIGHT - NAVBAR - 1) + NAVBAR

def lonToX(targetLon):
    """
    Returns pixel representation of longitude using given reference coords
    """
    return ((targetLon - minLon) / (maxLon - minLon)) * (MAP_WIDTH - SIDEBAR - 1) + SIDEBAR
    
class stdinRead(Thread):
    #set as a thread to allow for lags in stdin or no stdin at all
    def __init__(self, *largs, **kwargs):
        super(stdinRead, self).__init__()
        self.daemon = True
        self.queue = deque()
        self.quit = False
        self.index = 0
        num_waypts = raw_input();
        waypts = sys.stdin.readline().strip().split(';')
        for x in range(0, (int(num_waypts))):
            waypt = waypts[x].split(',')
            print "printing"
            print waypt
            print "done"
            y = latToY((float(waypt[0])))
            x = lonToX((float(waypt[1])))
            print 'Lon: %f' % x
            print 'Lat: %f' % y
            marker = Marker(pos = (x - 5, y - 5))
            marker.layout = map
            largs[0].add_widget(marker)



    def parse_data(self, data):
        """
        Parses semicolon dilimited list of floats into dictionary 
            w/ appropriate key values
        """
            
    #define NUM_MEMS           9
    #define DATA_FORMAT_STRING "%f;%f;%f;%f;%f;%f;%f;%f;%f\n"
    #define DATA_ARGS          &(env->wind_dir), &(env->wind_speed),\
    #                     &(env->app_wind_dir), &(env->app_wind_speed),\
    #                     &(boat->rud_pos), &(boat->sail_pos),\
    #                     &(boat->pos.lat), &(boat->pos.lon), &(boat->heading)

        data = data.split(';')
        return {'Wind Dir' : data[0], 'Wind Speed' : data[1],
                'App Wind Dir' : data[2], 'App Wind Speed' : data[3],
                'RudPos' : (float(data[4])), 'SailPos' : (float(data[5])),
                'Lat' : (float(data[6])), 'Lon' : (float(data[7])),
                'Heading' : (float(data[8])), 'Speed' : (float(data[9]))}

    def run(self):
        """
        Populates queue w/ dictionaries w/ each line of input
        """
        q = self.queue
        while not self.quit:
            data = sys.stdin.readline().strip()
            if data is None or len(data)==0:
                sleep(1)
                continue
            q.appendleft(self.parse_data(data))
            sleep(.01)

    def pop(self):
        return self.queue.pop()

class Marker(Widget):        
    pass

class MarkerGreen(Widget):
    pass

class Map(Widget):
    pass

class Updater(Widget):
    def pullData(self, map, envdata, rudderpos, sailpos, veloc, dt):
        """
        Updates all gui elements with fresh data from stdin queue
        """
        try:
            # The repetition of code here is sad but subtly difficult to abstract
            data_algor = self.stdin.pop()
            #data_human = self.stdin.pop()

            # update algorithm lat/lon
            x = lonToX(data_algor['Lon'])
            y = latToY(data_algor['Lat'])
            print 'Lon: %f' % x
            print 'Lat: %f' % y
            marker = MarkerGreen(pos = (x - 5, y - 5))
            marker.layout = map
            map.add_widget(marker)

            ## update human lat/lon
            #print 'Lon real: %f' % data_human['Lon']
            #print 'Latreal: %f' % data_human['Lon']
            #x = lonToX(data_human['Lon'])
            #y = latToY(data_human['Lat'])
            #print 'Lon: %f' % x
            #print 'Lat: %f' % y
            #markerGreen = MarkerGreen(pos = (x - 5, y - 5))
            #markerGreen.layout = map
            #map.add_widget(markerGreen)


            r = 75
            rudderpos.canvas.clear()
            # update algorithm rudder pos
            theta = (math.pi * data_algor['RudPos']) / 180
            with rudderpos.canvas:
                Color(0, 1, 0)
                Line(points = (100, 100, 100 + r * math.cos(theta), 100 + r * math.sin(theta)))

            ## update human rudder pos 
            #theta = (math.pi * data_human['RudPos']) / 180
            #with rudderpos.canvas:
            #    Color(0, 1, 0)
            #    Line(points = (100, 100, 100 + r * math.cos(theta), 100 + r * math.sin(theta)))

            sailpos.canvas.clear()
            # update algorithm sail pos
            theta = (math.pi * data_algor['SailPos']) / 180
            print 'Radius: %f' % r
            print 'Theta: %f' % theta
            print r*math.cos(theta)
            print r*math.sin(theta)
            with sailpos.canvas:
                Color(0, 1, 0)
                Line(points = (100, 350, 100 + r * math.cos(theta), 350 + r * math.sin(theta)))

            ## update human sail pos 
            #theta = (math.pi * data_human['SailPos']) / 180
            #with sailpos.canvas:
            #    Color(0, 1, 0)
            #    Line(points = (100, 350, 100 + r * math.cos(theta), 350 + r * math.sin(theta)))

            #veloc.canvas.clear()
            #r = data_algor['Speed'] + 75;

            # update algorithm velocity
            theta = (math.pi * data_algor['Heading']) / 180
            veloc.canvas.clear()
            with veloc.canvas:
                Color(0, 1, 0)
                Line(points = (100, 583, 100 + r * math.cos(theta), 583 + r * math.sin(theta)))

            ## update human velocity 
            #theta = (math.pi * data_human['Heading']) / 180
            #with veloc.canvas:
            #    Color(0, 1, 0)
            #    Line(points = (100, 583, 100 + r * math.cos(theta), 583 + r * math.sin(theta)))

            envdata.wind_direction = data_algor['Wind Dir']
            envdata.wind_speed = data_algor['Wind Speed']
            envdata.app_wind_direction = data_algor['App Wind Dir']
            envdata.app_wind_speed = data_algor['App Wind Speed']

        except Exception as e:
            print(e)
            return

class NavBar(GridLayout):
    def build(self):
        self.add_widget(self.envdata)
        self.add_widget(self.map)

class EnvData(GridLayout):
    # Public data basically that can be updated
    # Starts off null
    wind_direction = StringProperty('')
    wind_speed = StringProperty('')
    app_wind_direction = StringProperty('')
    app_wind_speed = StringProperty('')

class AlgorData(GridLayout):
    def build(self):
        self.add_widget(self.rp)
        self.add_widget(self.sp)
        self.add_widget(self.v)

class RudderPosition(Widget):
    def build(self):
        #self.add_widget(self.disp)
        pass

class Velocity(Widget):
    def build(self):
        pass

class SailPosition(Widget):
    def build(self):
        pass

class gui(App):
    def build_config(self, config):
        # set window height and width - give space for sidebars and map dimensions
        Config.set('graphics','width', MAP_WIDTH + SIDEBAR)
        Config.set('graphics','height', MAP_HEIGHT + NAVBAR)

    def build(self):
        # declare outter layout to hold inner elements
        layout = GridLayout(cols = 2, cols_minimum = {0 : SIDEBAR, 1 : MAP_WIDTH})

        # holds algorithm rudder / sail angles 
        algordata = AlgorData(rows = 3)
        algordata.rp = RudderPosition()
        algordata.sp = SailPosition()
        algordata.v = Velocity()
        algordata.build()

        # holds environmental data
        navbar = NavBar(rows = 2, rows_minimum = {0 : NAVBAR, 1: MAP_HEIGHT})
        navbar.envdata = EnvData(cols = 4)
        navbar.map = Map()
        navbar.build()

        layout.add_widget(algordata)
        layout.add_widget(navbar)

        updater = Updater()
        updater.stdin = stdinRead(navbar.map)
        updater.stdin.start()

        Clock.schedule_interval(partial(updater.pullData, navbar.map, navbar.envdata, 
            algordata.rp, algordata.sp, algordata.v), BAUD_RATE)

        return layout

if __name__ == '__main__':
    gui().run()
